// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DAQ_DNN_H_
#define FLATBUFFERS_GENERATED_DAQ_DNN_H_

#include "flatbuffers/flatbuffers.h"

namespace DNN {

struct Tensor;

struct QuantInfo;

struct Input;

struct Conv2D;

struct AvePool;

struct MaxPool;

struct Relu;

struct Softmax;

struct FC;

struct Add;

struct Concat;

struct DepthwiseConv2D;

struct BatchToSpace;

struct SpaceToBatch;

struct StridedSlice;

struct Mul;

struct AddScalar;

struct MulScalar;

struct Dequantize;

struct LRN;

struct Tanh;

struct Floor;

struct Logistic;

struct PReLU;

struct Pow;

struct Neg;

struct Minimum;

struct Maximum;

struct Log;

struct Layer;

struct Model;

/// Int8 is deprecated, but int8_data in table Tensor is used, since a Tensor just stores value, not care about quantization method
enum class DataType : int8_t {
  Float32 = 0,
  Int8 = 1,
  Int32 = 2,
  Float16 = 3,
  Bool8 = 4,
  QUANT8_ASYMM = 5,
  QUANT8_SYMM = 6,
  QUANT8_SYMM_PER_CHANNEL = 7,
  QUANT16_ASYMM = 8,
  QUANT16_SYMM = 9,
  MIN = Float32,
  MAX = QUANT16_SYMM
};

inline const DataType (&EnumValuesDataType())[10] {
  static const DataType values[] = {
    DataType::Float32,
    DataType::Int8,
    DataType::Int32,
    DataType::Float16,
    DataType::Bool8,
    DataType::QUANT8_ASYMM,
    DataType::QUANT8_SYMM,
    DataType::QUANT8_SYMM_PER_CHANNEL,
    DataType::QUANT16_ASYMM,
    DataType::QUANT16_SYMM
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[] = {
    "Float32",
    "Int8",
    "Int32",
    "Float16",
    "Bool8",
    "QUANT8_ASYMM",
    "QUANT8_SYMM",
    "QUANT8_SYMM_PER_CHANNEL",
    "QUANT16_ASYMM",
    "QUANT16_SYMM",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (e < DataType::Float32 || e > DataType::QUANT16_SYMM) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class FuseCode : int8_t {
  None = 0,
  Relu = 1,
  Relu1 = 2,
  Relu6 = 3,
  MIN = None,
  MAX = Relu6
};

inline const FuseCode (&EnumValuesFuseCode())[4] {
  static const FuseCode values[] = {
    FuseCode::None,
    FuseCode::Relu,
    FuseCode::Relu1,
    FuseCode::Relu6
  };
  return values;
}

inline const char * const *EnumNamesFuseCode() {
  static const char * const names[] = {
    "None",
    "Relu",
    "Relu1",
    "Relu6",
    nullptr
  };
  return names;
}

inline const char *EnumNameFuseCode(FuseCode e) {
  if (e < FuseCode::None || e > FuseCode::Relu6) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFuseCode()[index];
}

enum class LayerType : int8_t {
  Conv2D = 0,
  AvePool = 1,
  MaxPool = 2,
  Relu = 3,
  Softmax = 4,
  FC = 5,
  Add = 6,
  Concat = 7,
  DepthwiseConv2D = 8,
  BatchToSpace = 9,
  SpaceToBatch = 10,
  StridedSlice = 11,
  Mul = 12,
  AddScalar = 13,
  MulScalar = 14,
  Dequantize = 15,
  LRN = 16,
  Tanh = 17,
  Floor = 18,
  Logistic = 19,
  PReLU = 20,
  Pow = 21,
  Neg = 22,
  Minimum = 23,
  Maximum = 24,
  Log = 25,
  MIN = Conv2D,
  MAX = Log
};

inline const LayerType (&EnumValuesLayerType())[26] {
  static const LayerType values[] = {
    LayerType::Conv2D,
    LayerType::AvePool,
    LayerType::MaxPool,
    LayerType::Relu,
    LayerType::Softmax,
    LayerType::FC,
    LayerType::Add,
    LayerType::Concat,
    LayerType::DepthwiseConv2D,
    LayerType::BatchToSpace,
    LayerType::SpaceToBatch,
    LayerType::StridedSlice,
    LayerType::Mul,
    LayerType::AddScalar,
    LayerType::MulScalar,
    LayerType::Dequantize,
    LayerType::LRN,
    LayerType::Tanh,
    LayerType::Floor,
    LayerType::Logistic,
    LayerType::PReLU,
    LayerType::Pow,
    LayerType::Neg,
    LayerType::Minimum,
    LayerType::Maximum,
    LayerType::Log
  };
  return values;
}

inline const char * const *EnumNamesLayerType() {
  static const char * const names[] = {
    "Conv2D",
    "AvePool",
    "MaxPool",
    "Relu",
    "Softmax",
    "FC",
    "Add",
    "Concat",
    "DepthwiseConv2D",
    "BatchToSpace",
    "SpaceToBatch",
    "StridedSlice",
    "Mul",
    "AddScalar",
    "MulScalar",
    "Dequantize",
    "LRN",
    "Tanh",
    "Floor",
    "Logistic",
    "PReLU",
    "Pow",
    "Neg",
    "Minimum",
    "Maximum",
    "Log",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerType(LayerType e) {
  if (e < LayerType::Conv2D || e > LayerType::Log) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerType()[index];
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_INT8_DATA = 6,
    VT_FLOAT32_DATA = 8,
    VT_SHAPE = 10,
    VT_NAME = 12,
    VT_FLOAT16_DATA = 14,
    VT_BOOL8_DATA = 16,
    VT_INT32_DATA = 18
  };
  DataType data_type() const {
    return static_cast<DataType>(GetField<int8_t>(VT_DATA_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *int8_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INT8_DATA);
  }
  const flatbuffers::Vector<float> *float32_data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FLOAT32_DATA);
  }
  const flatbuffers::Vector<uint32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SHAPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// since flatbuffers doesn't have float16 data type, use uint16 instead
  const flatbuffers::Vector<uint16_t> *float16_data() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_FLOAT16_DATA);
  }
  const flatbuffers::Vector<uint8_t> *bool8_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BOOL8_DATA);
  }
  const flatbuffers::Vector<int32_t> *int32_data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INT32_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_INT8_DATA) &&
           verifier.VerifyVector(int8_data()) &&
           VerifyOffset(verifier, VT_FLOAT32_DATA) &&
           verifier.VerifyVector(float32_data()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FLOAT16_DATA) &&
           verifier.VerifyVector(float16_data()) &&
           VerifyOffset(verifier, VT_BOOL8_DATA) &&
           verifier.VerifyVector(bool8_data()) &&
           VerifyOffset(verifier, VT_INT32_DATA) &&
           verifier.VerifyVector(int32_data()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(DataType data_type) {
    fbb_.AddElement<int8_t>(Tensor::VT_DATA_TYPE, static_cast<int8_t>(data_type), 0);
  }
  void add_int8_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> int8_data) {
    fbb_.AddOffset(Tensor::VT_INT8_DATA, int8_data);
  }
  void add_float32_data(flatbuffers::Offset<flatbuffers::Vector<float>> float32_data) {
    fbb_.AddOffset(Tensor::VT_FLOAT32_DATA, float32_data);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_float16_data(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> float16_data) {
    fbb_.AddOffset(Tensor::VT_FLOAT16_DATA, float16_data);
  }
  void add_bool8_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bool8_data) {
    fbb_.AddOffset(Tensor::VT_BOOL8_DATA, bool8_data);
  }
  void add_int32_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> int32_data) {
    fbb_.AddOffset(Tensor::VT_INT32_DATA, int32_data);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType data_type = DataType::Float32,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> int8_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> float32_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> shape = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> float16_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bool8_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> int32_data = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_int32_data(int32_data);
  builder_.add_bool8_data(bool8_data);
  builder_.add_float16_data(float16_data);
  builder_.add_name(name);
  builder_.add_shape(shape);
  builder_.add_float32_data(float32_data);
  builder_.add_int8_data(int8_data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType data_type = DataType::Float32,
    const std::vector<uint8_t> *int8_data = nullptr,
    const std::vector<float> *float32_data = nullptr,
    const std::vector<uint32_t> *shape = nullptr,
    const char *name = nullptr,
    const std::vector<uint16_t> *float16_data = nullptr,
    const std::vector<uint8_t> *bool8_data = nullptr,
    const std::vector<int32_t> *int32_data = nullptr) {
  auto int8_data__ = int8_data ? _fbb.CreateVector<uint8_t>(*int8_data) : 0;
  auto float32_data__ = float32_data ? _fbb.CreateVector<float>(*float32_data) : 0;
  auto shape__ = shape ? _fbb.CreateVector<uint32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto float16_data__ = float16_data ? _fbb.CreateVector<uint16_t>(*float16_data) : 0;
  auto bool8_data__ = bool8_data ? _fbb.CreateVector<uint8_t>(*bool8_data) : 0;
  auto int32_data__ = int32_data ? _fbb.CreateVector<int32_t>(*int32_data) : 0;
  return DNN::CreateTensor(
      _fbb,
      data_type,
      int8_data__,
      float32_data__,
      shape__,
      name__,
      float16_data__,
      bool8_data__,
      int32_data__);
}

/// For weights, and for features
struct QuantInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA_TYPE = 6,
    VT_SCALES = 8,
    VT_ZERO_POINT = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  DataType data_type() const {
    return static_cast<DataType>(GetField<int8_t>(VT_DATA_TYPE, 0));
  }
  /// a float32 array of scales, the length will be 1 for non per-channel quantization, and be channelDim for per-channel quantization
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT) &&
           verifier.EndTable();
  }
};

struct QuantInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(QuantInfo::VT_NAME, name);
  }
  void add_data_type(DataType data_type) {
    fbb_.AddElement<int8_t>(QuantInfo::VT_DATA_TYPE, static_cast<int8_t>(data_type), 0);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(QuantInfo::VT_SCALES, scales);
  }
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(QuantInfo::VT_ZERO_POINT, zero_point, 0);
  }
  explicit QuantInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantInfoBuilder &operator=(const QuantInfoBuilder &);
  flatbuffers::Offset<QuantInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantInfo> CreateQuantInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    DataType data_type = DataType::Float32,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0,
    int32_t zero_point = 0) {
  QuantInfoBuilder builder_(_fbb);
  builder_.add_zero_point(zero_point);
  builder_.add_scales(scales);
  builder_.add_name(name);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantInfo> CreateQuantInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    DataType data_type = DataType::Float32,
    const std::vector<float> *scales = nullptr,
    int32_t zero_point = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return DNN::CreateQuantInfo(
      _fbb,
      name__,
      data_type,
      scales__,
      zero_point);
}

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_NAME = 6
  };
  const flatbuffers::Vector<uint32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SHAPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct InputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> shape) {
    fbb_.AddOffset(Input::VT_SHAPE, shape);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Input::VT_NAME, name);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputBuilder &operator=(const InputBuilder &);
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> shape = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  InputBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *shape = nullptr,
    const char *name = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<uint32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return DNN::CreateInput(
      _fbb,
      shape__,
      name__);
}

struct Conv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_PADS = 10,
    VT_STRIDES = 12,
    VT_FUSE = 14,
    VT_OUTPUT = 16
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *weight() const {
    return GetPointer<const flatbuffers::String *>(VT_WEIGHT);
  }
  const flatbuffers::String *bias() const {
    return GetPointer<const flatbuffers::String *>(VT_BIAS);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  FuseCode fuse() const {
    return static_cast<FuseCode>(GetField<int8_t>(VT_FUSE, 0));
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyString(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyString(bias()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int8_t>(verifier, VT_FUSE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct Conv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Conv2D::VT_INPUT, input);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::String> weight) {
    fbb_.AddOffset(Conv2D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::String> bias) {
    fbb_.AddOffset(Conv2D::VT_BIAS, bias);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Conv2D::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Conv2D::VT_STRIDES, strides);
  }
  void add_fuse(FuseCode fuse) {
    fbb_.AddElement<int8_t>(Conv2D::VT_FUSE, static_cast<int8_t>(fuse), 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Conv2D::VT_OUTPUT, output);
  }
  explicit Conv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DBuilder &operator=(const Conv2DBuilder &);
  flatbuffers::Offset<Conv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2D> CreateConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> weight = 0,
    flatbuffers::Offset<flatbuffers::String> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    FuseCode fuse = FuseCode::None,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  Conv2DBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_input(input);
  builder_.add_fuse(fuse);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2D> CreateConv2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *weight = nullptr,
    const char *bias = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    FuseCode fuse = FuseCode::None,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto weight__ = weight ? _fbb.CreateString(weight) : 0;
  auto bias__ = bias ? _fbb.CreateString(bias) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateConv2D(
      _fbb,
      input__,
      weight__,
      bias__,
      pads__,
      strides__,
      fuse,
      output__);
}

struct AvePool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_KERNEL_SHAPE = 6,
    VT_PADS = 8,
    VT_STRIDES = 10,
    VT_FUSE = 12,
    VT_OUTPUT = 14
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::Vector<int32_t> *kernel_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNEL_SHAPE);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  FuseCode fuse() const {
    return static_cast<FuseCode>(GetField<int8_t>(VT_FUSE, 0));
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_KERNEL_SHAPE) &&
           verifier.VerifyVector(kernel_shape()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int8_t>(verifier, VT_FUSE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct AvePoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(AvePool::VT_INPUT, input);
  }
  void add_kernel_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape) {
    fbb_.AddOffset(AvePool::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(AvePool::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(AvePool::VT_STRIDES, strides);
  }
  void add_fuse(FuseCode fuse) {
    fbb_.AddElement<int8_t>(AvePool::VT_FUSE, static_cast<int8_t>(fuse), 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(AvePool::VT_OUTPUT, output);
  }
  explicit AvePoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AvePoolBuilder &operator=(const AvePoolBuilder &);
  flatbuffers::Offset<AvePool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AvePool>(end);
    return o;
  }
};

inline flatbuffers::Offset<AvePool> CreateAvePool(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    FuseCode fuse = FuseCode::None,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  AvePoolBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_input(input);
  builder_.add_fuse(fuse);
  return builder_.Finish();
}

inline flatbuffers::Offset<AvePool> CreateAvePoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const std::vector<int32_t> *kernel_shape = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    FuseCode fuse = FuseCode::None,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto kernel_shape__ = kernel_shape ? _fbb.CreateVector<int32_t>(*kernel_shape) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateAvePool(
      _fbb,
      input__,
      kernel_shape__,
      pads__,
      strides__,
      fuse,
      output__);
}

struct MaxPool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_KERNEL_SHAPE = 6,
    VT_PADS = 8,
    VT_STRIDES = 10,
    VT_FUSE = 12,
    VT_OUTPUT = 14
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::Vector<int32_t> *kernel_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNEL_SHAPE);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  FuseCode fuse() const {
    return static_cast<FuseCode>(GetField<int8_t>(VT_FUSE, 0));
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_KERNEL_SHAPE) &&
           verifier.VerifyVector(kernel_shape()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int8_t>(verifier, VT_FUSE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct MaxPoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(MaxPool::VT_INPUT, input);
  }
  void add_kernel_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape) {
    fbb_.AddOffset(MaxPool::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(MaxPool::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(MaxPool::VT_STRIDES, strides);
  }
  void add_fuse(FuseCode fuse) {
    fbb_.AddElement<int8_t>(MaxPool::VT_FUSE, static_cast<int8_t>(fuse), 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(MaxPool::VT_OUTPUT, output);
  }
  explicit MaxPoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaxPoolBuilder &operator=(const MaxPoolBuilder &);
  flatbuffers::Offset<MaxPool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaxPool>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaxPool> CreateMaxPool(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    FuseCode fuse = FuseCode::None,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  MaxPoolBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_input(input);
  builder_.add_fuse(fuse);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaxPool> CreateMaxPoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const std::vector<int32_t> *kernel_shape = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    FuseCode fuse = FuseCode::None,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto kernel_shape__ = kernel_shape ? _fbb.CreateVector<int32_t>(*kernel_shape) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateMaxPool(
      _fbb,
      input__,
      kernel_shape__,
      pads__,
      strides__,
      fuse,
      output__);
}

struct Relu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct ReluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Relu::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Relu::VT_OUTPUT, output);
  }
  explicit ReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReluBuilder &operator=(const ReluBuilder &);
  flatbuffers::Offset<Relu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu> CreateRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  ReluBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Relu> CreateReluDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateRelu(
      _fbb,
      input__,
      output__);
}

struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct SoftmaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Softmax::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Softmax::VT_OUTPUT, output);
  }
  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxBuilder &operator=(const SoftmaxBuilder &);
  flatbuffers::Offset<Softmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Softmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<Softmax> CreateSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  SoftmaxBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Softmax> CreateSoftmaxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateSoftmax(
      _fbb,
      input__,
      output__);
}

struct FC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_FUSE = 10,
    VT_OUTPUT = 12
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *weight() const {
    return GetPointer<const flatbuffers::String *>(VT_WEIGHT);
  }
  const flatbuffers::String *bias() const {
    return GetPointer<const flatbuffers::String *>(VT_BIAS);
  }
  FuseCode fuse() const {
    return static_cast<FuseCode>(GetField<int8_t>(VT_FUSE, 0));
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyString(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyString(bias()) &&
           VerifyField<int8_t>(verifier, VT_FUSE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct FCBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(FC::VT_INPUT, input);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::String> weight) {
    fbb_.AddOffset(FC::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::String> bias) {
    fbb_.AddOffset(FC::VT_BIAS, bias);
  }
  void add_fuse(FuseCode fuse) {
    fbb_.AddElement<int8_t>(FC::VT_FUSE, static_cast<int8_t>(fuse), 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(FC::VT_OUTPUT, output);
  }
  explicit FCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FCBuilder &operator=(const FCBuilder &);
  flatbuffers::Offset<FC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FC>(end);
    return o;
  }
};

inline flatbuffers::Offset<FC> CreateFC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> weight = 0,
    flatbuffers::Offset<flatbuffers::String> bias = 0,
    FuseCode fuse = FuseCode::None,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  FCBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_input(input);
  builder_.add_fuse(fuse);
  return builder_.Finish();
}

inline flatbuffers::Offset<FC> CreateFCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *weight = nullptr,
    const char *bias = nullptr,
    FuseCode fuse = FuseCode::None,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto weight__ = weight ? _fbb.CreateString(weight) : 0;
  auto bias__ = bias ? _fbb.CreateString(bias) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateFC(
      _fbb,
      input__,
      weight__,
      bias__,
      fuse,
      output__);
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT1 = 4,
    VT_INPUT2 = 6,
    VT_FUSE = 8,
    VT_OUTPUT = 10
  };
  const flatbuffers::String *input1() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT1);
  }
  const flatbuffers::String *input2() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT2);
  }
  FuseCode fuse() const {
    return static_cast<FuseCode>(GetField<int8_t>(VT_FUSE, 0));
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT1) &&
           verifier.VerifyString(input1()) &&
           VerifyOffset(verifier, VT_INPUT2) &&
           verifier.VerifyString(input2()) &&
           VerifyField<int8_t>(verifier, VT_FUSE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input1(flatbuffers::Offset<flatbuffers::String> input1) {
    fbb_.AddOffset(Add::VT_INPUT1, input1);
  }
  void add_input2(flatbuffers::Offset<flatbuffers::String> input2) {
    fbb_.AddOffset(Add::VT_INPUT2, input2);
  }
  void add_fuse(FuseCode fuse) {
    fbb_.AddElement<int8_t>(Add::VT_FUSE, static_cast<int8_t>(fuse), 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Add::VT_OUTPUT, output);
  }
  explicit AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Add>(end);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input1 = 0,
    flatbuffers::Offset<flatbuffers::String> input2 = 0,
    FuseCode fuse = FuseCode::None,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input2(input2);
  builder_.add_input1(input1);
  builder_.add_fuse(fuse);
  return builder_.Finish();
}

inline flatbuffers::Offset<Add> CreateAddDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input1 = nullptr,
    const char *input2 = nullptr,
    FuseCode fuse = FuseCode::None,
    const char *output = nullptr) {
  auto input1__ = input1 ? _fbb.CreateString(input1) : 0;
  auto input2__ = input2 ? _fbb.CreateString(input2) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateAdd(
      _fbb,
      input1__,
      input2__,
      fuse,
      output__);
}

struct Concat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4,
    VT_AXIS = 6,
    VT_OUTPUT = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUTS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct ConcatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Concat::VT_INPUTS, inputs);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Concat::VT_AXIS, axis, 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Concat::VT_OUTPUT, output);
  }
  explicit ConcatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatBuilder &operator=(const ConcatBuilder &);
  flatbuffers::Offset<Concat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Concat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Concat> CreateConcat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs = 0,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  ConcatBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_axis(axis);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<Concat> CreateConcatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *inputs = nullptr,
    int32_t axis = 0,
    const char *output = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*inputs) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateConcat(
      _fbb,
      inputs__,
      axis,
      output__);
}

struct DepthwiseConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_PADS = 10,
    VT_STRIDES = 12,
    VT_DEPTH_MULTIPLIER = 14,
    VT_FUSE = 16,
    VT_OUTPUT = 18
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *weight() const {
    return GetPointer<const flatbuffers::String *>(VT_WEIGHT);
  }
  const flatbuffers::String *bias() const {
    return GetPointer<const flatbuffers::String *>(VT_BIAS);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  FuseCode fuse() const {
    return static_cast<FuseCode>(GetField<int8_t>(VT_FUSE, 0));
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyString(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyString(bias()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER) &&
           VerifyField<int8_t>(verifier, VT_FUSE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct DepthwiseConv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(DepthwiseConv2D::VT_INPUT, input);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::String> weight) {
    fbb_.AddOffset(DepthwiseConv2D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::String> bias) {
    fbb_.AddOffset(DepthwiseConv2D::VT_BIAS, bias);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(DepthwiseConv2D::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(DepthwiseConv2D::VT_STRIDES, strides);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fuse(FuseCode fuse) {
    fbb_.AddElement<int8_t>(DepthwiseConv2D::VT_FUSE, static_cast<int8_t>(fuse), 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(DepthwiseConv2D::VT_OUTPUT, output);
  }
  explicit DepthwiseConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthwiseConv2DBuilder &operator=(const DepthwiseConv2DBuilder &);
  flatbuffers::Offset<DepthwiseConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2D> CreateDepthwiseConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> weight = 0,
    flatbuffers::Offset<flatbuffers::String> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    int32_t depth_multiplier = 0,
    FuseCode fuse = FuseCode::None,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  DepthwiseConv2DBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_input(input);
  builder_.add_fuse(fuse);
  return builder_.Finish();
}

inline flatbuffers::Offset<DepthwiseConv2D> CreateDepthwiseConv2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *weight = nullptr,
    const char *bias = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    int32_t depth_multiplier = 0,
    FuseCode fuse = FuseCode::None,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto weight__ = weight ? _fbb.CreateString(weight) : 0;
  auto bias__ = bias ? _fbb.CreateString(bias) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateDepthwiseConv2D(
      _fbb,
      input__,
      weight__,
      bias__,
      pads__,
      strides__,
      depth_multiplier,
      fuse,
      output__);
}

struct BatchToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_BLOCK_SIZES = 6,
    VT_OUTPUT = 8
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct BatchToSpaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(BatchToSpace::VT_INPUT, input);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(BatchToSpace::VT_BLOCK_SIZES, block_sizes);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(BatchToSpace::VT_OUTPUT, output);
  }
  explicit BatchToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceBuilder &operator=(const BatchToSpaceBuilder &);
  flatbuffers::Offset<BatchToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  BatchToSpaceBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_block_sizes(block_sizes);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const std::vector<int32_t> *block_sizes = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateBatchToSpace(
      _fbb,
      input__,
      block_sizes__,
      output__);
}

struct SpaceToBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_BLOCK_SIZES = 6,
    VT_PADS = 8,
    VT_OUTPUT = 10
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::Vector<int32_t> *block_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_SIZES);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_BLOCK_SIZES) &&
           verifier.VerifyVector(block_sizes()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct SpaceToBatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(SpaceToBatch::VT_INPUT, input);
  }
  void add_block_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes) {
    fbb_.AddOffset(SpaceToBatch::VT_BLOCK_SIZES, block_sizes);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(SpaceToBatch::VT_PADS, pads);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(SpaceToBatch::VT_OUTPUT, output);
  }
  explicit SpaceToBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchBuilder &operator=(const SpaceToBatchBuilder &);
  flatbuffers::Offset<SpaceToBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  SpaceToBatchBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_pads(pads);
  builder_.add_block_sizes(block_sizes);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const std::vector<int32_t> *block_sizes = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto block_sizes__ = block_sizes ? _fbb.CreateVector<int32_t>(*block_sizes) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateSpaceToBatch(
      _fbb,
      input__,
      block_sizes__,
      pads__,
      output__);
}

struct StridedSlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_STARTS = 6,
    VT_ENDS = 8,
    VT_STRIDES = 10,
    VT_BEGIN_MASK = 12,
    VT_END_MASK = 14,
    VT_SHRINK_AXIS_MASK = 16,
    VT_OUTPUT = 18
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::Vector<int32_t> *starts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STARTS);
  }
  const flatbuffers::Vector<int32_t> *ends() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENDS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_STARTS) &&
           verifier.VerifyVector(starts()) &&
           VerifyOffset(verifier, VT_ENDS) &&
           verifier.VerifyVector(ends()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int32_t>(verifier, VT_END_MASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct StridedSliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(StridedSlice::VT_INPUT, input);
  }
  void add_starts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts) {
    fbb_.AddOffset(StridedSlice::VT_STARTS, starts);
  }
  void add_ends(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends) {
    fbb_.AddOffset(StridedSlice::VT_ENDS, ends);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(StridedSlice::VT_STRIDES, strides);
  }
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_END_MASK, end_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(StridedSlice::VT_OUTPUT, output);
  }
  explicit StridedSliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceBuilder &operator=(const StridedSliceBuilder &);
  flatbuffers::Offset<StridedSlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  StridedSliceBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  builder_.add_strides(strides);
  builder_.add_ends(ends);
  builder_.add_starts(starts);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<StridedSlice> CreateStridedSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const std::vector<int32_t> *starts = nullptr,
    const std::vector<int32_t> *ends = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t shrink_axis_mask = 0,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto starts__ = starts ? _fbb.CreateVector<int32_t>(*starts) : 0;
  auto ends__ = ends ? _fbb.CreateVector<int32_t>(*ends) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateStridedSlice(
      _fbb,
      input__,
      starts__,
      ends__,
      strides__,
      begin_mask,
      end_mask,
      shrink_axis_mask,
      output__);
}

struct Mul FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT1 = 4,
    VT_INPUT2 = 6,
    VT_FUSE = 8,
    VT_OUTPUT = 10
  };
  const flatbuffers::String *input1() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT1);
  }
  const flatbuffers::String *input2() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT2);
  }
  FuseCode fuse() const {
    return static_cast<FuseCode>(GetField<int8_t>(VT_FUSE, 0));
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT1) &&
           verifier.VerifyString(input1()) &&
           VerifyOffset(verifier, VT_INPUT2) &&
           verifier.VerifyString(input2()) &&
           VerifyField<int8_t>(verifier, VT_FUSE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct MulBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input1(flatbuffers::Offset<flatbuffers::String> input1) {
    fbb_.AddOffset(Mul::VT_INPUT1, input1);
  }
  void add_input2(flatbuffers::Offset<flatbuffers::String> input2) {
    fbb_.AddOffset(Mul::VT_INPUT2, input2);
  }
  void add_fuse(FuseCode fuse) {
    fbb_.AddElement<int8_t>(Mul::VT_FUSE, static_cast<int8_t>(fuse), 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Mul::VT_OUTPUT, output);
  }
  explicit MulBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulBuilder &operator=(const MulBuilder &);
  flatbuffers::Offset<Mul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mul>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mul> CreateMul(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input1 = 0,
    flatbuffers::Offset<flatbuffers::String> input2 = 0,
    FuseCode fuse = FuseCode::None,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  MulBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input2(input2);
  builder_.add_input1(input1);
  builder_.add_fuse(fuse);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mul> CreateMulDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input1 = nullptr,
    const char *input2 = nullptr,
    FuseCode fuse = FuseCode::None,
    const char *output = nullptr) {
  auto input1__ = input1 ? _fbb.CreateString(input1) : 0;
  auto input2__ = input2 ? _fbb.CreateString(input2) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateMul(
      _fbb,
      input1__,
      input2__,
      fuse,
      output__);
}

struct AddScalar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_SCALAR = 6,
    VT_FUSE = 8,
    VT_OUTPUT = 10
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  float scalar() const {
    return GetField<float>(VT_SCALAR, 0.0f);
  }
  FuseCode fuse() const {
    return static_cast<FuseCode>(GetField<int8_t>(VT_FUSE, 0));
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyField<float>(verifier, VT_SCALAR) &&
           VerifyField<int8_t>(verifier, VT_FUSE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct AddScalarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(AddScalar::VT_INPUT, input);
  }
  void add_scalar(float scalar) {
    fbb_.AddElement<float>(AddScalar::VT_SCALAR, scalar, 0.0f);
  }
  void add_fuse(FuseCode fuse) {
    fbb_.AddElement<int8_t>(AddScalar::VT_FUSE, static_cast<int8_t>(fuse), 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(AddScalar::VT_OUTPUT, output);
  }
  explicit AddScalarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddScalarBuilder &operator=(const AddScalarBuilder &);
  flatbuffers::Offset<AddScalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddScalar>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddScalar> CreateAddScalar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    float scalar = 0.0f,
    FuseCode fuse = FuseCode::None,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  AddScalarBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_scalar(scalar);
  builder_.add_input(input);
  builder_.add_fuse(fuse);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddScalar> CreateAddScalarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    float scalar = 0.0f,
    FuseCode fuse = FuseCode::None,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateAddScalar(
      _fbb,
      input__,
      scalar,
      fuse,
      output__);
}

struct MulScalar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_SCALAR = 6,
    VT_FUSE = 8,
    VT_OUTPUT = 10
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  float scalar() const {
    return GetField<float>(VT_SCALAR, 0.0f);
  }
  FuseCode fuse() const {
    return static_cast<FuseCode>(GetField<int8_t>(VT_FUSE, 0));
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyField<float>(verifier, VT_SCALAR) &&
           VerifyField<int8_t>(verifier, VT_FUSE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct MulScalarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(MulScalar::VT_INPUT, input);
  }
  void add_scalar(float scalar) {
    fbb_.AddElement<float>(MulScalar::VT_SCALAR, scalar, 0.0f);
  }
  void add_fuse(FuseCode fuse) {
    fbb_.AddElement<int8_t>(MulScalar::VT_FUSE, static_cast<int8_t>(fuse), 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(MulScalar::VT_OUTPUT, output);
  }
  explicit MulScalarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulScalarBuilder &operator=(const MulScalarBuilder &);
  flatbuffers::Offset<MulScalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulScalar>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulScalar> CreateMulScalar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    float scalar = 0.0f,
    FuseCode fuse = FuseCode::None,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  MulScalarBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_scalar(scalar);
  builder_.add_input(input);
  builder_.add_fuse(fuse);
  return builder_.Finish();
}

inline flatbuffers::Offset<MulScalar> CreateMulScalarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    float scalar = 0.0f,
    FuseCode fuse = FuseCode::None,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateMulScalar(
      _fbb,
      input__,
      scalar,
      fuse,
      output__);
}

struct Dequantize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct DequantizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Dequantize::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Dequantize::VT_OUTPUT, output);
  }
  explicit DequantizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DequantizeBuilder &operator=(const DequantizeBuilder &);
  flatbuffers::Offset<Dequantize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dequantize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dequantize> CreateDequantize(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  DequantizeBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Dequantize> CreateDequantizeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateDequantize(
      _fbb,
      input__,
      output__);
}

struct LRN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_RADIUS = 6,
    VT_BIAS = 8,
    VT_ALPHA = 10,
    VT_BETA = 12,
    VT_OUTPUT = 14
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyField<int32_t>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct LRNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(LRN::VT_INPUT, input);
  }
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LRN::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LRN::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LRN::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LRN::VT_BETA, beta, 0.0f);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(LRN::VT_OUTPUT, output);
  }
  explicit LRNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LRNBuilder &operator=(const LRNBuilder &);
  flatbuffers::Offset<LRN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRN>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRN> CreateLRN(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  LRNBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<LRN> CreateLRNDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateLRN(
      _fbb,
      input__,
      radius,
      bias,
      alpha,
      beta,
      output__);
}

struct Tanh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct TanhBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Tanh::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Tanh::VT_OUTPUT, output);
  }
  explicit TanhBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TanhBuilder &operator=(const TanhBuilder &);
  flatbuffers::Offset<Tanh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tanh>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tanh> CreateTanh(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  TanhBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tanh> CreateTanhDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateTanh(
      _fbb,
      input__,
      output__);
}

struct Floor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct FloorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Floor::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Floor::VT_OUTPUT, output);
  }
  explicit FloorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorBuilder &operator=(const FloorBuilder &);
  flatbuffers::Offset<Floor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Floor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Floor> CreateFloor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  FloorBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Floor> CreateFloorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateFloor(
      _fbb,
      input__,
      output__);
}

struct Logistic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct LogisticBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Logistic::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Logistic::VT_OUTPUT, output);
  }
  explicit LogisticBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogisticBuilder &operator=(const LogisticBuilder &);
  flatbuffers::Offset<Logistic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Logistic>(end);
    return o;
  }
};

inline flatbuffers::Offset<Logistic> CreateLogistic(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  LogisticBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Logistic> CreateLogisticDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateLogistic(
      _fbb,
      input__,
      output__);
}

struct PReLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_ALPHA = 6,
    VT_OUTPUT = 8
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *alpha() const {
    return GetPointer<const flatbuffers::String *>(VT_ALPHA);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyString(alpha()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct PReLUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(PReLU::VT_INPUT, input);
  }
  void add_alpha(flatbuffers::Offset<flatbuffers::String> alpha) {
    fbb_.AddOffset(PReLU::VT_ALPHA, alpha);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(PReLU::VT_OUTPUT, output);
  }
  explicit PReLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PReLUBuilder &operator=(const PReLUBuilder &);
  flatbuffers::Offset<PReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PReLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<PReLU> CreatePReLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> alpha = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  PReLUBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_alpha(alpha);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<PReLU> CreatePReLUDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *alpha = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto alpha__ = alpha ? _fbb.CreateString(alpha) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreatePReLU(
      _fbb,
      input__,
      alpha__,
      output__);
}

struct Pow FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_EXP = 6,
    VT_OUTPUT = 8
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *exp() const {
    return GetPointer<const flatbuffers::String *>(VT_EXP);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_EXP) &&
           verifier.VerifyString(exp()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct PowBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Pow::VT_INPUT, input);
  }
  void add_exp(flatbuffers::Offset<flatbuffers::String> exp) {
    fbb_.AddOffset(Pow::VT_EXP, exp);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Pow::VT_OUTPUT, output);
  }
  explicit PowBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowBuilder &operator=(const PowBuilder &);
  flatbuffers::Offset<Pow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pow>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pow> CreatePow(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> exp = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  PowBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_exp(exp);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pow> CreatePowDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *exp = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto exp__ = exp ? _fbb.CreateString(exp) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreatePow(
      _fbb,
      input__,
      exp__,
      output__);
}

struct Neg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct NegBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Neg::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Neg::VT_OUTPUT, output);
  }
  explicit NegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegBuilder &operator=(const NegBuilder &);
  flatbuffers::Offset<Neg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Neg>(end);
    return o;
  }
};

inline flatbuffers::Offset<Neg> CreateNeg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  NegBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Neg> CreateNegDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateNeg(
      _fbb,
      input__,
      output__);
}

struct Minimum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT1 = 4,
    VT_INPUT2 = 6,
    VT_OUTPUT = 8
  };
  const flatbuffers::String *input1() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT1);
  }
  const flatbuffers::String *input2() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT2);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT1) &&
           verifier.VerifyString(input1()) &&
           VerifyOffset(verifier, VT_INPUT2) &&
           verifier.VerifyString(input2()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct MinimumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input1(flatbuffers::Offset<flatbuffers::String> input1) {
    fbb_.AddOffset(Minimum::VT_INPUT1, input1);
  }
  void add_input2(flatbuffers::Offset<flatbuffers::String> input2) {
    fbb_.AddOffset(Minimum::VT_INPUT2, input2);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Minimum::VT_OUTPUT, output);
  }
  explicit MinimumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MinimumBuilder &operator=(const MinimumBuilder &);
  flatbuffers::Offset<Minimum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Minimum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Minimum> CreateMinimum(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input1 = 0,
    flatbuffers::Offset<flatbuffers::String> input2 = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  MinimumBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input2(input2);
  builder_.add_input1(input1);
  return builder_.Finish();
}

inline flatbuffers::Offset<Minimum> CreateMinimumDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input1 = nullptr,
    const char *input2 = nullptr,
    const char *output = nullptr) {
  auto input1__ = input1 ? _fbb.CreateString(input1) : 0;
  auto input2__ = input2 ? _fbb.CreateString(input2) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateMinimum(
      _fbb,
      input1__,
      input2__,
      output__);
}

struct Maximum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT1 = 4,
    VT_INPUT2 = 6,
    VT_OUTPUT = 8
  };
  const flatbuffers::String *input1() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT1);
  }
  const flatbuffers::String *input2() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT2);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT1) &&
           verifier.VerifyString(input1()) &&
           VerifyOffset(verifier, VT_INPUT2) &&
           verifier.VerifyString(input2()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct MaximumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input1(flatbuffers::Offset<flatbuffers::String> input1) {
    fbb_.AddOffset(Maximum::VT_INPUT1, input1);
  }
  void add_input2(flatbuffers::Offset<flatbuffers::String> input2) {
    fbb_.AddOffset(Maximum::VT_INPUT2, input2);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Maximum::VT_OUTPUT, output);
  }
  explicit MaximumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumBuilder &operator=(const MaximumBuilder &);
  flatbuffers::Offset<Maximum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Maximum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Maximum> CreateMaximum(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input1 = 0,
    flatbuffers::Offset<flatbuffers::String> input2 = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  MaximumBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input2(input2);
  builder_.add_input1(input1);
  return builder_.Finish();
}

inline flatbuffers::Offset<Maximum> CreateMaximumDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input1 = nullptr,
    const char *input2 = nullptr,
    const char *output = nullptr) {
  auto input1__ = input1 ? _fbb.CreateString(input1) : 0;
  auto input2__ = input2 ? _fbb.CreateString(input2) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateMaximum(
      _fbb,
      input1__,
      input2__,
      output__);
}

struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct LogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Log::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Log::VT_OUTPUT, output);
  }
  explicit LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogBuilder &operator=(const LogBuilder &);
  flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline flatbuffers::Offset<Log> CreateLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  LogBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Log> CreateLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return DNN::CreateLog(
      _fbb,
      input__,
      output__);
}

struct Layer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_CONV2D_PARAM = 6,
    VT_AVEPOOL_PARAM = 8,
    VT_MAXPOOL_PARAM = 10,
    VT_RELU_PARAM = 12,
    VT_SOFTMAX_PARAM = 14,
    VT_FC_PARAM = 16,
    VT_ADD_PARAM = 18,
    VT_CONCAT_PARAM = 20,
    VT_DEPTHWISECONV2D_PARAM = 22,
    VT_BATCHTOSPACE_PARAM = 24,
    VT_SPACETOBATCH_PARAM = 26,
    VT_STRIDEDSLICE_PARAM = 28,
    VT_MUL_PARAM = 30,
    VT_ADDSCALAR_PARAM = 32,
    VT_MULSCALAR_PARAM = 34,
    VT_DEQUANTIZE_PARAM = 36,
    VT_LRN_PARAM = 38,
    VT_TANH_PARAM = 40,
    VT_FLOOR_PARAM = 42,
    VT_LOGISTIC_PARAM = 44,
    VT_PRELU_PARAM = 46,
    VT_POW_PARAM = 48,
    VT_NEG_PARAM = 50,
    VT_MINIMUM_PARAM = 52,
    VT_MAXIMUM_PARAM = 54,
    VT_LOG_PARAM = 56
  };
  LayerType type() const {
    return static_cast<LayerType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const Conv2D *Conv2D_param() const {
    return GetPointer<const Conv2D *>(VT_CONV2D_PARAM);
  }
  const AvePool *AvePool_param() const {
    return GetPointer<const AvePool *>(VT_AVEPOOL_PARAM);
  }
  const MaxPool *MaxPool_param() const {
    return GetPointer<const MaxPool *>(VT_MAXPOOL_PARAM);
  }
  const Relu *Relu_param() const {
    return GetPointer<const Relu *>(VT_RELU_PARAM);
  }
  const Softmax *Softmax_param() const {
    return GetPointer<const Softmax *>(VT_SOFTMAX_PARAM);
  }
  const FC *FC_param() const {
    return GetPointer<const FC *>(VT_FC_PARAM);
  }
  const Add *Add_param() const {
    return GetPointer<const Add *>(VT_ADD_PARAM);
  }
  const Concat *Concat_param() const {
    return GetPointer<const Concat *>(VT_CONCAT_PARAM);
  }
  const DepthwiseConv2D *DepthwiseConv2D_param() const {
    return GetPointer<const DepthwiseConv2D *>(VT_DEPTHWISECONV2D_PARAM);
  }
  const BatchToSpace *BatchToSpace_param() const {
    return GetPointer<const BatchToSpace *>(VT_BATCHTOSPACE_PARAM);
  }
  const SpaceToBatch *SpaceToBatch_param() const {
    return GetPointer<const SpaceToBatch *>(VT_SPACETOBATCH_PARAM);
  }
  const StridedSlice *StridedSlice_param() const {
    return GetPointer<const StridedSlice *>(VT_STRIDEDSLICE_PARAM);
  }
  const Mul *Mul_param() const {
    return GetPointer<const Mul *>(VT_MUL_PARAM);
  }
  const AddScalar *AddScalar_param() const {
    return GetPointer<const AddScalar *>(VT_ADDSCALAR_PARAM);
  }
  const MulScalar *MulScalar_param() const {
    return GetPointer<const MulScalar *>(VT_MULSCALAR_PARAM);
  }
  const Dequantize *Dequantize_param() const {
    return GetPointer<const Dequantize *>(VT_DEQUANTIZE_PARAM);
  }
  const LRN *LRN_param() const {
    return GetPointer<const LRN *>(VT_LRN_PARAM);
  }
  const Tanh *Tanh_param() const {
    return GetPointer<const Tanh *>(VT_TANH_PARAM);
  }
  const Floor *Floor_param() const {
    return GetPointer<const Floor *>(VT_FLOOR_PARAM);
  }
  const Logistic *Logistic_param() const {
    return GetPointer<const Logistic *>(VT_LOGISTIC_PARAM);
  }
  const PReLU *PReLU_param() const {
    return GetPointer<const PReLU *>(VT_PRELU_PARAM);
  }
  const Pow *Pow_param() const {
    return GetPointer<const Pow *>(VT_POW_PARAM);
  }
  const Neg *Neg_param() const {
    return GetPointer<const Neg *>(VT_NEG_PARAM);
  }
  const Minimum *Minimum_param() const {
    return GetPointer<const Minimum *>(VT_MINIMUM_PARAM);
  }
  const Maximum *Maximum_param() const {
    return GetPointer<const Maximum *>(VT_MAXIMUM_PARAM);
  }
  const Log *Log_param() const {
    return GetPointer<const Log *>(VT_LOG_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CONV2D_PARAM) &&
           verifier.VerifyTable(Conv2D_param()) &&
           VerifyOffset(verifier, VT_AVEPOOL_PARAM) &&
           verifier.VerifyTable(AvePool_param()) &&
           VerifyOffset(verifier, VT_MAXPOOL_PARAM) &&
           verifier.VerifyTable(MaxPool_param()) &&
           VerifyOffset(verifier, VT_RELU_PARAM) &&
           verifier.VerifyTable(Relu_param()) &&
           VerifyOffset(verifier, VT_SOFTMAX_PARAM) &&
           verifier.VerifyTable(Softmax_param()) &&
           VerifyOffset(verifier, VT_FC_PARAM) &&
           verifier.VerifyTable(FC_param()) &&
           VerifyOffset(verifier, VT_ADD_PARAM) &&
           verifier.VerifyTable(Add_param()) &&
           VerifyOffset(verifier, VT_CONCAT_PARAM) &&
           verifier.VerifyTable(Concat_param()) &&
           VerifyOffset(verifier, VT_DEPTHWISECONV2D_PARAM) &&
           verifier.VerifyTable(DepthwiseConv2D_param()) &&
           VerifyOffset(verifier, VT_BATCHTOSPACE_PARAM) &&
           verifier.VerifyTable(BatchToSpace_param()) &&
           VerifyOffset(verifier, VT_SPACETOBATCH_PARAM) &&
           verifier.VerifyTable(SpaceToBatch_param()) &&
           VerifyOffset(verifier, VT_STRIDEDSLICE_PARAM) &&
           verifier.VerifyTable(StridedSlice_param()) &&
           VerifyOffset(verifier, VT_MUL_PARAM) &&
           verifier.VerifyTable(Mul_param()) &&
           VerifyOffset(verifier, VT_ADDSCALAR_PARAM) &&
           verifier.VerifyTable(AddScalar_param()) &&
           VerifyOffset(verifier, VT_MULSCALAR_PARAM) &&
           verifier.VerifyTable(MulScalar_param()) &&
           VerifyOffset(verifier, VT_DEQUANTIZE_PARAM) &&
           verifier.VerifyTable(Dequantize_param()) &&
           VerifyOffset(verifier, VT_LRN_PARAM) &&
           verifier.VerifyTable(LRN_param()) &&
           VerifyOffset(verifier, VT_TANH_PARAM) &&
           verifier.VerifyTable(Tanh_param()) &&
           VerifyOffset(verifier, VT_FLOOR_PARAM) &&
           verifier.VerifyTable(Floor_param()) &&
           VerifyOffset(verifier, VT_LOGISTIC_PARAM) &&
           verifier.VerifyTable(Logistic_param()) &&
           VerifyOffset(verifier, VT_PRELU_PARAM) &&
           verifier.VerifyTable(PReLU_param()) &&
           VerifyOffset(verifier, VT_POW_PARAM) &&
           verifier.VerifyTable(Pow_param()) &&
           VerifyOffset(verifier, VT_NEG_PARAM) &&
           verifier.VerifyTable(Neg_param()) &&
           VerifyOffset(verifier, VT_MINIMUM_PARAM) &&
           verifier.VerifyTable(Minimum_param()) &&
           VerifyOffset(verifier, VT_MAXIMUM_PARAM) &&
           verifier.VerifyTable(Maximum_param()) &&
           VerifyOffset(verifier, VT_LOG_PARAM) &&
           verifier.VerifyTable(Log_param()) &&
           verifier.EndTable();
  }
};

struct LayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(LayerType type) {
    fbb_.AddElement<int8_t>(Layer::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_Conv2D_param(flatbuffers::Offset<Conv2D> Conv2D_param) {
    fbb_.AddOffset(Layer::VT_CONV2D_PARAM, Conv2D_param);
  }
  void add_AvePool_param(flatbuffers::Offset<AvePool> AvePool_param) {
    fbb_.AddOffset(Layer::VT_AVEPOOL_PARAM, AvePool_param);
  }
  void add_MaxPool_param(flatbuffers::Offset<MaxPool> MaxPool_param) {
    fbb_.AddOffset(Layer::VT_MAXPOOL_PARAM, MaxPool_param);
  }
  void add_Relu_param(flatbuffers::Offset<Relu> Relu_param) {
    fbb_.AddOffset(Layer::VT_RELU_PARAM, Relu_param);
  }
  void add_Softmax_param(flatbuffers::Offset<Softmax> Softmax_param) {
    fbb_.AddOffset(Layer::VT_SOFTMAX_PARAM, Softmax_param);
  }
  void add_FC_param(flatbuffers::Offset<FC> FC_param) {
    fbb_.AddOffset(Layer::VT_FC_PARAM, FC_param);
  }
  void add_Add_param(flatbuffers::Offset<Add> Add_param) {
    fbb_.AddOffset(Layer::VT_ADD_PARAM, Add_param);
  }
  void add_Concat_param(flatbuffers::Offset<Concat> Concat_param) {
    fbb_.AddOffset(Layer::VT_CONCAT_PARAM, Concat_param);
  }
  void add_DepthwiseConv2D_param(flatbuffers::Offset<DepthwiseConv2D> DepthwiseConv2D_param) {
    fbb_.AddOffset(Layer::VT_DEPTHWISECONV2D_PARAM, DepthwiseConv2D_param);
  }
  void add_BatchToSpace_param(flatbuffers::Offset<BatchToSpace> BatchToSpace_param) {
    fbb_.AddOffset(Layer::VT_BATCHTOSPACE_PARAM, BatchToSpace_param);
  }
  void add_SpaceToBatch_param(flatbuffers::Offset<SpaceToBatch> SpaceToBatch_param) {
    fbb_.AddOffset(Layer::VT_SPACETOBATCH_PARAM, SpaceToBatch_param);
  }
  void add_StridedSlice_param(flatbuffers::Offset<StridedSlice> StridedSlice_param) {
    fbb_.AddOffset(Layer::VT_STRIDEDSLICE_PARAM, StridedSlice_param);
  }
  void add_Mul_param(flatbuffers::Offset<Mul> Mul_param) {
    fbb_.AddOffset(Layer::VT_MUL_PARAM, Mul_param);
  }
  void add_AddScalar_param(flatbuffers::Offset<AddScalar> AddScalar_param) {
    fbb_.AddOffset(Layer::VT_ADDSCALAR_PARAM, AddScalar_param);
  }
  void add_MulScalar_param(flatbuffers::Offset<MulScalar> MulScalar_param) {
    fbb_.AddOffset(Layer::VT_MULSCALAR_PARAM, MulScalar_param);
  }
  void add_Dequantize_param(flatbuffers::Offset<Dequantize> Dequantize_param) {
    fbb_.AddOffset(Layer::VT_DEQUANTIZE_PARAM, Dequantize_param);
  }
  void add_LRN_param(flatbuffers::Offset<LRN> LRN_param) {
    fbb_.AddOffset(Layer::VT_LRN_PARAM, LRN_param);
  }
  void add_Tanh_param(flatbuffers::Offset<Tanh> Tanh_param) {
    fbb_.AddOffset(Layer::VT_TANH_PARAM, Tanh_param);
  }
  void add_Floor_param(flatbuffers::Offset<Floor> Floor_param) {
    fbb_.AddOffset(Layer::VT_FLOOR_PARAM, Floor_param);
  }
  void add_Logistic_param(flatbuffers::Offset<Logistic> Logistic_param) {
    fbb_.AddOffset(Layer::VT_LOGISTIC_PARAM, Logistic_param);
  }
  void add_PReLU_param(flatbuffers::Offset<PReLU> PReLU_param) {
    fbb_.AddOffset(Layer::VT_PRELU_PARAM, PReLU_param);
  }
  void add_Pow_param(flatbuffers::Offset<Pow> Pow_param) {
    fbb_.AddOffset(Layer::VT_POW_PARAM, Pow_param);
  }
  void add_Neg_param(flatbuffers::Offset<Neg> Neg_param) {
    fbb_.AddOffset(Layer::VT_NEG_PARAM, Neg_param);
  }
  void add_Minimum_param(flatbuffers::Offset<Minimum> Minimum_param) {
    fbb_.AddOffset(Layer::VT_MINIMUM_PARAM, Minimum_param);
  }
  void add_Maximum_param(flatbuffers::Offset<Maximum> Maximum_param) {
    fbb_.AddOffset(Layer::VT_MAXIMUM_PARAM, Maximum_param);
  }
  void add_Log_param(flatbuffers::Offset<Log> Log_param) {
    fbb_.AddOffset(Layer::VT_LOG_PARAM, Log_param);
  }
  explicit LayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LayerBuilder &operator=(const LayerBuilder &);
  flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Layer> CreateLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    LayerType type = LayerType::Conv2D,
    flatbuffers::Offset<Conv2D> Conv2D_param = 0,
    flatbuffers::Offset<AvePool> AvePool_param = 0,
    flatbuffers::Offset<MaxPool> MaxPool_param = 0,
    flatbuffers::Offset<Relu> Relu_param = 0,
    flatbuffers::Offset<Softmax> Softmax_param = 0,
    flatbuffers::Offset<FC> FC_param = 0,
    flatbuffers::Offset<Add> Add_param = 0,
    flatbuffers::Offset<Concat> Concat_param = 0,
    flatbuffers::Offset<DepthwiseConv2D> DepthwiseConv2D_param = 0,
    flatbuffers::Offset<BatchToSpace> BatchToSpace_param = 0,
    flatbuffers::Offset<SpaceToBatch> SpaceToBatch_param = 0,
    flatbuffers::Offset<StridedSlice> StridedSlice_param = 0,
    flatbuffers::Offset<Mul> Mul_param = 0,
    flatbuffers::Offset<AddScalar> AddScalar_param = 0,
    flatbuffers::Offset<MulScalar> MulScalar_param = 0,
    flatbuffers::Offset<Dequantize> Dequantize_param = 0,
    flatbuffers::Offset<LRN> LRN_param = 0,
    flatbuffers::Offset<Tanh> Tanh_param = 0,
    flatbuffers::Offset<Floor> Floor_param = 0,
    flatbuffers::Offset<Logistic> Logistic_param = 0,
    flatbuffers::Offset<PReLU> PReLU_param = 0,
    flatbuffers::Offset<Pow> Pow_param = 0,
    flatbuffers::Offset<Neg> Neg_param = 0,
    flatbuffers::Offset<Minimum> Minimum_param = 0,
    flatbuffers::Offset<Maximum> Maximum_param = 0,
    flatbuffers::Offset<Log> Log_param = 0) {
  LayerBuilder builder_(_fbb);
  builder_.add_Log_param(Log_param);
  builder_.add_Maximum_param(Maximum_param);
  builder_.add_Minimum_param(Minimum_param);
  builder_.add_Neg_param(Neg_param);
  builder_.add_Pow_param(Pow_param);
  builder_.add_PReLU_param(PReLU_param);
  builder_.add_Logistic_param(Logistic_param);
  builder_.add_Floor_param(Floor_param);
  builder_.add_Tanh_param(Tanh_param);
  builder_.add_LRN_param(LRN_param);
  builder_.add_Dequantize_param(Dequantize_param);
  builder_.add_MulScalar_param(MulScalar_param);
  builder_.add_AddScalar_param(AddScalar_param);
  builder_.add_Mul_param(Mul_param);
  builder_.add_StridedSlice_param(StridedSlice_param);
  builder_.add_SpaceToBatch_param(SpaceToBatch_param);
  builder_.add_BatchToSpace_param(BatchToSpace_param);
  builder_.add_DepthwiseConv2D_param(DepthwiseConv2D_param);
  builder_.add_Concat_param(Concat_param);
  builder_.add_Add_param(Add_param);
  builder_.add_FC_param(FC_param);
  builder_.add_Softmax_param(Softmax_param);
  builder_.add_Relu_param(Relu_param);
  builder_.add_MaxPool_param(MaxPool_param);
  builder_.add_AvePool_param(AvePool_param);
  builder_.add_Conv2D_param(Conv2D_param);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYERS = 4,
    VT_INITIALIZERS = 6,
    VT_INPUTS = 8,
    VT_QUANT_INFOS = 10,
    VT_OUTPUTS = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<Layer>> *layers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Layer>> *>(VT_LAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *initializers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *>(VT_INITIALIZERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Input>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Input>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<QuantInfo>> *quant_infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<QuantInfo>> *>(VT_QUANT_INFOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LAYERS) &&
           verifier.VerifyVector(layers()) &&
           verifier.VerifyVectorOfTables(layers()) &&
           VerifyOffset(verifier, VT_INITIALIZERS) &&
           verifier.VerifyVector(initializers()) &&
           verifier.VerifyVectorOfTables(initializers()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_QUANT_INFOS) &&
           verifier.VerifyVector(quant_infos()) &&
           verifier.VerifyVectorOfTables(quant_infos()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_layers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Layer>>> layers) {
    fbb_.AddOffset(Model::VT_LAYERS, layers);
  }
  void add_initializers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> initializers) {
    fbb_.AddOffset(Model::VT_INITIALIZERS, initializers);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Input>>> inputs) {
    fbb_.AddOffset(Model::VT_INPUTS, inputs);
  }
  void add_quant_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuantInfo>>> quant_infos) {
    fbb_.AddOffset(Model::VT_QUANT_INFOS, quant_infos);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Model::VT_OUTPUTS, outputs);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Layer>>> layers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> initializers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Input>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuantInfo>>> quant_infos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_quant_infos(quant_infos);
  builder_.add_inputs(inputs);
  builder_.add_initializers(initializers);
  builder_.add_layers(layers);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Layer>> *layers = nullptr,
    const std::vector<flatbuffers::Offset<Tensor>> *initializers = nullptr,
    const std::vector<flatbuffers::Offset<Input>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<QuantInfo>> *quant_infos = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputs = nullptr) {
  auto layers__ = layers ? _fbb.CreateVector<flatbuffers::Offset<Layer>>(*layers) : 0;
  auto initializers__ = initializers ? _fbb.CreateVector<flatbuffers::Offset<Tensor>>(*initializers) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<Input>>(*inputs) : 0;
  auto quant_infos__ = quant_infos ? _fbb.CreateVector<flatbuffers::Offset<QuantInfo>>(*quant_infos) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputs) : 0;
  return DNN::CreateModel(
      _fbb,
      layers__,
      initializers__,
      inputs__,
      quant_infos__,
      outputs__);
}

inline const DNN::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<DNN::Model>(buf);
}

inline const DNN::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<DNN::Model>(buf);
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DNN::Model>(nullptr);
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DNN::Model>(nullptr);
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DNN::Model> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DNN::Model> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DNN

#endif  // FLATBUFFERS_GENERATED_DAQ_DNN_H_
